#! /bin/bash

set -e;

VMFORMAT=vmdk;
TYPE="";
NAME="";
ARCHI=amd64;
SIZE="5G";
DEBIANVERSION="jessie"
BRANCH="";
EXTRAPACKAGES="";
TMPNAME="tmp`date +%s`";
REMOVE="yes";
COSYREPO="http://cosyverif-debian.lip6.fr jessie-testing/";
DEBUGMODE=false;
VERBOSEMODE=false;

usage(){
    perl -ne 'use Term::ANSIColor qw(:constants); if(/^\s*(debian|cosy|buildeb|kernel|minimal|repo|jenkins-slave|without-recommends)\s*$/){print GREEN, $_, RESET;}elsif(/^(((\s*-\w(\s*\<.*?\>)?)|(\s*--\w[-\w]*(=[-a-zA-Z\/]+)?)),?\s*)*$/){print BRIGHT_BLUE, $_, RESET;}elsif(/^\s*\*\*.*$/ || /^\s*.*?\*\*\s$/){print BRIGHT_RED, $_, RESET;}else{print;}' << EOF
Usage : $0 [OPTIONS]
Creates docker images or virtual disks.
** You have to be root in order to execute this command ! **

Options :
 -a <archi>, --arch=ARCH, --architecture=ARCH  
      Architecture. It can either be amd64 or i386. Default: $ARCHI
 -b <branch>, --branch=BRANCH 
      What kind of docker image/vm you want to  create. It can be one of the  8
      following value:
        debian
          Create a virtual disk/docker image containing a debian system without
          a kernel (unless  you  want  to  create a virtual disk image. In that
          case, there will be a kernel). 
        cosy   
          Create a minimal virtual disk image with a kernel, and a  user  named
          'cosyverif'
        buildeb 
          Create a minimal virtual disk/docker image  which  contains  all  the
          dependencies of buildeb.
        kernel 
          Create a virtual disk/docker image with a kernel.
        minimal
          Create a minimal virtual disk/docker image. It means that  there  are
          no manpages and no documentation installed.
        repo
          Create a minimal virtual disk image which  contains  a kernel and all
          the software (correctly configured) one might need to  setup a debian
          repository.
        jenkins-slave 
           Create a minimal virtual disk image  which  contains  a  kernel  and
           everything you need to setup a jenkins slave. 
        without-recommends 
           Create a virtual disk/docker image which doesn't install recommended
           packages when you want to install a package.
      ** This option is mandatory ! **
 -D, --debug, --debug-mode
      Debug mode. 
 -f <format>, --format=FORMAT, --vm-format=FORMAT, --format-vm=FORMAT 
      Indicate what type of virtual disk image to create. Can be  one of these:
      vmdk, qcow2, qcow, raw. Default: $VMFORMAT.
      If you want to build a docker image, you must not use this option.
 -h, --help       
      Print this
 -n <name>, --name=NAME
      The name you want to give to your docker image or your vm.
 -p <packages>, --install=PACKAGES, --extra-packages=PACKAGES, 
  --packages=PACKAGES
      List of packages you want to install in the resulting virtual disk/docker
      image. The list of packages must be written like that: 
      package1,package2,package3,...
 -r <yes/no>, --remove=yes/no  
      (Do or Don't) Remove temporary  docker images  and  files. Default value:
      $REMOVE. It means that temporary files and docker images will be removed
 -R <repo>, --repository=REPO, --repo=REPO, --cosy-repo=REPO
      Address  of  the  debian  repository where are located all the  cosyverif
      related packages. It must follow this pattern: <repo_address>,<section>. 
      Default: $COSYREPO
      **<section> MUST be coherent with the debian version you want to use.**
 -s <size>, --size=SIZE, --vmsize=SIZE, --sizevm=SIZE 
      Size of the virtual disk image. Default : $SIZE.
 -t <type>, --type=TYPE
      Indicate what you want to create. <type> can be one of these:
        image: A docker image will be created
        vm: A virtual disk image will be created.
      ** This option is mandatory. **
 -v <version>, --version=VER, --debian-version=VER, --release=VER
      What Debian  version you  want to use to create your docker image or your
      virtual  disk  image.  It  must  either  be a release code name (squeeze,
      wheezy, ...) or a symbolic name (stable, testing, unstable, ...). Default
      value: $DEBIANVERSION.
 -V, --verbose, --verbose-mode
      Verbose mode
EOF
}

are_you_root () {
    [ ${EUID:=1000} -ne 0 ] && {
	echo "Error: You have to be root to run this script" >&2 ;
	exit 1 ;
    } || :
}

verbose_mode () {
    [ $VERBOSEMODE = true ] && {
	cat
    } || {
	cat >> /dev/null
    }
}

do_dockerfile () {
    dockerfile_name=$1;
    cp dockerfiles/$dockerfile_name Dockerfile;
    perl -pi -e 's/BASE_IMAGE/'"$TMPNAME"'/;' Dockerfile;
    case $dockerfile_name in
	install-extrapackages)
	    perl -pi -e 's/PACKAGES/'"$EXTRAPACKAGES"'/;' Dockerfile;
	    perl -pi -e 's!REPOSITORY SUITE!'"$COSYREPO"'!;' Dockerfile;
	    COSYTMP="`echo $COSYREPO | cut -d' ' -f1`";
	    COSYTMP="`echo "$COSYTMP" | perl -ne 'print $1 if /^(.+)\/?/;'`";
	    perl -pi -e 's!REPOSITORY!'"$COSYTMP"'!;' Dockerfile;;
	clean)
	    docker.io rmi -f $(docker.io images | grep "^<none>" | awk \
		'{print $3}') 2>/dev/null || :;;	
	with-repo | with-jenkins-slave)
	    perl -pi -e 's!REPOSITORY SUITE!'"$COSYREPO"'!;' Dockerfile;
	    COSYTMP="`echo $COSYREPO | cut -d' ' -f1`";
	    COSYTMP="`echo "$COSYTMP" | perl -ne 'print $1 if /^(.+)\/?/;'`";
	    perl -pi -e 's!REPOSITORY!'"$COSYTMP"'!;' Dockerfile;;
	*)
	    echo ;;
    esac
    echo "Executing dockerfile $dockerfile_name ..."
    docker build -t $TMPNAME . | verbose_mode;
    docker export $(docker run -d $TMPNAME echo)  | docker import - $TMPNAME
    rm Dockerfile;
    echo "Dockerfile $dockerfile_name successfuly executed !";
    docker.io rm -f $(docker.io ps -a -q) 2>/dev/null || :;
}

do_debian () {
    echo "Downloading Debian ...";
    /usr/share/docker.io/contrib/mkimage-debootstrap.sh \
	-v minbase \
	-a $ARCHI \
	-t debiantarball.createimvm.tmp.tar \
	$DEBIANVERSION \
	http://http.debian.net/debian | verbose_mode
    echo "Debian has been downloaded";
    cat debiantarball.createimvm.tmp.tar | docker import - $TMPNAME >>/dev/null
    [ "$REMOVE" == "yes" ] && {
	rm debiantarball.createimvm.tmp.tar;
    }
    echo "Removing useless packages";
    do_dockerfile remove-useless-packages;
    echo "Useless packages removed !";
}

create_final_image () {
    echo "Creating image $NAME ...";
    docker.io run -d $TMPNAME echo |xargs  docker export | \
	docker import - $NAME >/dev/null
    echo "Image $NAME created !";
    docker.io rm -f $(docker.io ps -a -q) 2>/dev/null || :;
    [ "$REMOVE" == "yes" ] && {
	docker.io rmi -f $TMPNAME;
    }
}

create_vm () {
    echo "Exporting docker image ..."
    docker.io run -d $TMPNAME echo |xargs docker export > $NAME.tar
    echo "docker image successfuly exported";

    docker.io rm -f $(docker.io ps -a -q) 2>/dev/null || :;
    [ "$REMOVE" == "yes" ] && {
	docker.io rmi -f $TMPNAME | verbose_mode;
    }

    echo "Compressing tarball ...";
    gzip $NAME.tar;
    echo "Tarball compressed !";
    echo "Creating virtual disk image ...";
    
    [ $VERBOSEMODE = true ] && {
	[ $DEBUGMODE = true ] && {
	    genvmopts="-v -D";
	} || {
	    genvmopts="-v";
	}
    } || {
	[ $DEBUGMODE = true ] && {
	    genvmopts="-D";
	} || {
	    genvmopts="";
	}	
    }

    genvm $genvmopts -a $ARCHI -d $NAME.tar.gz -e -f $VMFORMAT -s $SIZE $NAME
    echo "Virtual disk image successfuly created !";
    [ "$REMOVE" == "yes" ] && {
	rm -rf $NAME.tar.gz;
    }
}

f_seen=false;
s_seen=false;
[ $# -eq 0 ] && {
    echo "You can't use this script without arguments">&2;
    echo "Use $0 --help for more informations">&2;
    exit 1;
}

while [ ! -z "$1" ]
do
    case $1 in 
	-a)
	    ([ -z "$2" ] || [[ "$2" =~ ^-[a-zA-Z] || "$2" =~ ^--[a-zA-Z]* ]]) \
		&&  {
		echo "Error: -a option requires an argument">&2;
		exit 1;
	    }
	    [[ "$2" != "amd64" && "$2" != "i386" ]] && {
		echo "Error: Unknown architecture $2";
		exit 1;
	    } 
	    ARCHI=$2;
	    shift 2;;
	--arch=*|--architecture=*)
	    ARCHI=${1#--*=};
	    [[ "$ARCHI" != "amd64" && "$ARCHI" != "i386" ]] && {
		echo "Error: Unknown architecture $ARCHI";
		exit 1;
	    } 
	    shift;;
	-b)
	    ([ -z "$2" ] || [[ "$2" =~ ^-[a-zA-Z] || "$2" =~ ^--[a-zA-Z]* ]]) \
		&& {
		echo "Error: -b option requires an argument">&2;
		exit 1;
	    }
	    case $2 in
		debian | cosy | buildeb | kernel | minimal | repo |\
                jenkins-slave | without-recommends) 
		    BRANCH="$2";;
		*)
		    echo "Error: Unknown branch $2">&2;
		    exit 1;;
	    esac
	    shift 2;;
	--branch=*)
	    BRANCH=${1#--*=};
	    case $BRANCH in
		debian | cosy | buildeb | kernel | minimal | repo |\
                jenkins-slave | without-recommends) 
		    shift 1;;
		*)
		    echo "Error: Unknown branch $BRANCH">&2;
		    exit 1;;
	    esac;;
	-D|--debug|--debug-mode)
	    DEBUGMODE=true;
	    set -x;
	    shift;;
	-f)
	    ([ -z "$2" ] || [[ "$2" =~ ^-[a-zA-Z] || "$2" =~ ^--[a-zA-Z]* ]]) \
		&& {
		echo "Error: -f option requires an argument">&2;
		exit 1;
	    }
	    
	    case $2 in
		vmdk | qcow | qcow2 | raw) 
		    VMFORMAT="$2";;
		*)
		    echo "Error: Unknown virtual disk image format $2">&2;
		    exit 1;;
	    esac
	    f_seen=true;
	    shift 2;;
	--format=* | --vm-format=* | --format-vm=*)
	    VMFORMAT=${1#--*=};
	    case $VMFORMAT in
                vmdk | qcow | qcow2 | raw) 
		    shift 1;;
		*)
		    echo "Error: Unknown virtual disk image format $VMFORMAT"\
                    >&2;
		    exit 1;;
	    esac;;
	-h | --help)
	    usage;
	    exit 0;;
	-n)
	    ([ -z "$2" ] || [[ "$2" =~ ^-[a-zA-Z] || "$2" =~ ^--[a-zA-Z]* ]]) \
		&& {
		echo "Error: -n option requires an argument">&2;
		exit 1;
	    }
	    NAME="$2";
	    shift 2;;
	--name=*)
	   NAME=${1#--*=};
	   [ -z "$NAME" ] && {
	       echo "Error: Invalid name for --name">&2;
	       exit 1;
	   } || { 
	       shift 1;
	   }
	   ;;
	-p)
	    ([ -z "$2" ] || [[ "$2" =~ ^-[a-zA-Z] || "$2" =~ ^--[a-zA-Z]* ]]) \
		&& {
		echo "Error: -p option requires an argument">&2;
		exit 1;
	    }
	    EXTRAPACKAGES="$(echo "$2" | tr , ' ')";
	    shift 2;;
	--install=* | --extra-packages=* | --packages=*)
	   EXTRAPACKAGES=${1#--*=};
	   [ -z "$EXTRAPACKAGES" ] && {
	       echo "Error: Invalid list of packages for ${1%=*}">&2;
	       exit 1;
	   } || { 
	       EXTRAPACKAGES="$(echo "$EXTRAPACKAGES" | tr , ' ')";
	       shift 1;
	   }
	   ;;
	-r)    
	    ([ -z "$2" ] || [[ "$2" =~ ^-[a-zA-Z] || "$2" =~ ^--[a-zA-Z]* ]]) \
		&& {
		echo "Error: -r option requires an argument">&2;
		exit 1;
	    }
	   case $2 in
	       yes | y | true)
		   REMOVE="yes";;
	       no | n | false)
		   REMOVE="no";;
	       *)
		   echo"Error: Invalid value $2 for -r option">&2;
		   exit 1;;
	   esac
	   shift 2;;
	--remove=*)
	    REMOVE=${1#--*=};
	    case $REMOVE in
		yes | y | true)
		    REMOVE="yes";;
		no | n | false)
		    REMOVE="no";;
		*)
		   echo"Error: Invalid value $REMOVE for -r option">&2;
		   exit 1;;
	    esac
	    shift;;	
	-R)
	    ([ -z "$2" ] || [[ "$2" =~ ^-[a-zA-Z] || "$2" =~ ^--[a-zA-Z]* ]]) \
		&& {
		echo "Error: -R option requires an argument">&2;
		exit 1;
	    }
	    COSYREPO="$(echo "$2" | tr , ' ');"
	    shift 2;;
	--repository=* | --repo=* | --cosy-repo=*)
	    COSYREPO=${1#--*=};
	    COSYREPO="$(echo "$COSYREPO" | tr , ' ')";
	    shift;;
	-s)
	    ([ -z "$2" ] || [[ "$2" =~ ^-[a-zA-Z] || "$2" =~ ^--[a-zA-Z]* ]]) \
		&& {
		echo "Error: -s option requires an argument">&2;
		exit 1;
	    }
	    SIZE="$2";
	    s_seen=true;
	    shift 2;;
	--size=* | --vmsize=* | --sizevm=*)
	    SIZE={$1#--*=};
	    [ -z "$SIZE" ] && {
		echo "Error: Invalid size for ${1%=*} option">&2;
		exit 1;
	    } || {
		s_seen=true;
		shift;
	    }
	    ;;
	-t)
	    ([ -z "$2" ] || [[ "$2" =~ ^-[a-zA-Z] || "$2" =~ ^--[a-zA-Z]* ]]) \
		&& {
		echo "Error: -t option requires an argument">&2;
		exit 1;
	    }
	    [[ "$2" != "image" && "$2" != "vm" ]] && {
		echo "Error: Unknow type $2 for -t option">&2;
		exit 1;
	    }
	    TYPE=$2;
	    shift 2;;
	--type=*)
	    TYPE=${1#--*=};
	    [[ "$TYPE" != "image" && "$TYPE" != "vm" ]] && {
		echo "Error: Unknow type $TYPE for --type option">&2;
		exit 1;
	    }
	    shift;;
	-v)
	    ([ -z "$2" ] || [[ "$2" =~ ^-[a-zA-Z] || "$2" =~ ^--[a-zA-Z]* ]]) \
		&& {
		echo "Error: -v option requires an argument">&2;
		exit 1;
	    }
	    
	    [[ "$2" =~ ^([0-9]+\.?)+$ ]] && {
		echo "Error: You can't use a version number for -v">&2;
		exit 1;
	    }
	    DEBIANVERSION="$2";
	    shift 2;;
	--version=* | --debian-version=* | --release=*)
	    DEBIANVERSION=${1#--*=};
	    [[ "$2" =~ ^([0-9]+\.?)+$ ]] && {
		echo "Error: You can't use a version number for -v">&2;
		exit 1;
	    }
	    shift;;
	-V | --verbose | --verbose-mode)
	    VERBOSEMODE=true;
	    shift;;
	--*)
	    echo "Unknown option ${1%=*}">&2;
	    echo "Use $0 --help for more informations">&2;
	    exit 1;;
	-*)
	    echo "Unknown option $1">&2;
	    echo "Use $0 --help for more informations">&2;
	    exit 1;;
	*)
	    exit;;
    esac
done;


if [ -z "$TYPE" ]
then
    echo "ERROR : You haven't specified what you want to create">&2;
    echo "ERROR : You have to use -t">&2;
    exit 5;
fi

if [ -z "$BRANCH" ]
then
    echo "ERROR : You haven't specified what kind of $TYPE you want to create"\
>&2;
    echo "ERROR : You have to use -b to specify it."
    exit 6;
fi

if [ "$TYPE" == "image" ] && [ $f_seen = true ]
then
    echo "WARNING : You want to build a docker image, you shouldn't use -f";
    echo "WARNING : -f option ignored";
fi

if [ "$TYPE" == "image" ] && [ $s_seen = true ]
then
    echo "WARNING : You want to build a docker image, you shouldn't use -s";
    echo "WARNING : -s option ignored";
fi

are_you_root;

if [ -z "$NAME" ]
then
    if [ "$TYPE" == "image" ]
    then
	NAME="$BRANCH:$DEBIANVERSION-$ARCHI";
    else 
	NAME="$BRANCH.$DEBIANVERSION.$ARCHI.$VMFORMAT";
    fi
fi
 
do_debian;

case $BRANCH in
    debian)
	[ "$TYPE" == "vm" ] && {
	    do_dockerfile with-kernel;
	}
	;;
    without-recommends)
	do_dockerfile without-recommends;
	[ "$TYPE" == "vm" ] && {
	    do_dockerfile with-kernel;
	}
	;;	
    minimal)
	do_dockerfile without-recommends;
	do_dockerfile with-minimal;
	[ "$TYPE" == "vm" ] && {
	    do_dockerfile with-kernel;
	}
	;;
    kernel)
	do_dockerfile with-kernel;;
    buildeb)
	do_dockerfile without-recommends;
	do_dockerfile with-minimal;
	do_dockerfile with-buildeb;
	[ "$TYPE" == "vm" ] && {
	    do_dockerfile with-kernel;
	}
	;;
    repo)
	do_dockerfile without-recommends;
	do_dockerfile with-minimal;
	do_dockerfile with-kernel;
	do_dockerfile with-repo;;
    jenkins-slave)
	do_dockerfile without-recommends;
	do_dockerfile with-minimal;
	do_dockerfile with-kernel;
	do_dockerfile with-jenkins-slave;;
    cosy)
	do_dockerfile without-recommends;
	do_dockerfile with-kernel;
	do_dockerfile with-cosy;;
    *)
	echo "should not be";;
esac

if [ ! -z "$EXTRAPACKAGES" ]
then
    do_dockerfile install-extrapackages;
fi

do_dockerfile clean;

if [ "$TYPE" == "image" ]
then
    create_final_image;
else
    create_vm;
fi
